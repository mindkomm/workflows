on:
  workflow_call:
    inputs:
      package_name:
        required: false
        type: string
        description: "Custom name for the package (defaults to repository name)"
      cleanup_file:
        required: false
        type: string
        description: "Path to cleanup configuration file (defaults to 'cleanup.txt')"
        default: "cleanup.txt"
    secrets:
      READ_PACKAGES_TOKEN:
        description: Read packages token
        required: true
      COMPOSER_AUTH_JSON:
        description: Authentication for privately hosted packages and repositories as a JSON formatted object.
        required: true
  workflow_dispatch:
    inputs:
      tag:
        required: true
        type: string
        description: "The tag to create the package for"
      package_name:
        required: false
        type: string
        description: "Custom name for the package (defaults to repository name)"
      cleanup_file:
        required: false
        type: string
        description: "Path to cleanup configuration file (defaults to 'cleanup.txt')"
        default: "cleanup.txt"

name: Release

jobs:
  release:
    # Only run when not manually triggered
    if: "${{ github.event.inputs.tag == '' }}"
    uses: mindkomm/workflows/.github/workflows/release.yml@main

  create-package:
    runs-on: ubuntu-latest
    needs: release
    if: |
      always() &&
      needs.release.result == 'skipped' ||
      (needs.release.outputs.created || github.event.inputs.tag != '')
    env:
      COMPOSER_AUTH: "${{ secrets.COMPOSER_AUTH_JSON }}"
      PACKAGE_NAME: ${{ inputs.package_name != '' && inputs.package_name || github.event.repository.name }}
    steps:
    # Set current tag, either from the release event or from the workflow_call event
    - run: echo "TAG=${{ github.event.inputs.tag != '' && github.event.inputs.tag || needs.release.outputs.tag }}" >> $GITHUB_OUTPUT
      id: tag

    # Set zip file name
    - run: echo "ZIP_FILENAME=${{ env.PACKAGE_NAME }}-${{ steps.tag.outputs.TAG }}.zip" >> $GITHUB_OUTPUT
      id: zip-filename

    - uses: actions/checkout@v5
      with:
        path: repo
        ref: ${{ steps.tag.outputs.TAG }}

    # Archive the repository, so we get all files without the .git directory and exluded files from .gitattributes
    - run: |
        cd repo
        ls -la
        git archive --output $GITHUB_WORKSPACE/${{ steps.zip-filename.outputs.ZIP_FILENAME }} ${{ steps.tag.outputs.TAG }}
        cd $GITHUB_WORKSPACE
        rm -rf repo
        unzip $GITHUB_WORKSPACE/${{ steps.zip-filename.outputs.ZIP_FILENAME }}
        rm -rf $GITHUB_WORKSPACE/${{ steps.zip-filename.outputs.ZIP_FILENAME }}
        ls -la

    # Get PHP version from .php-version file
    - run: echo PHP_VERSION=$(cat .php-version) >> $GITHUB_OUTPUT
      id: php-version

    # Install Composer dependencies
    - uses: mindkomm/workflows/.github/actions/composer@main
      with:
        COMPOSER_ARGS: --prefer-dist --no-progress --no-interaction --no-dev --optimize-autoloader --classmap-authoritative --verbose
        PHP_VERSION: ${{ steps.php-version.outputs.PHP_VERSION }}
        COMPOSER_CONFIG: ${{ vars.COMPOSER_CONFIG_JSON }}

    # Check if package.json exists
    - run: echo "PACKAGE_JSON_EXISTS=$(test -f package.json && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
      id: check-package-json

    - uses: actions/setup-node@v4
      if: steps.check-package-json.outputs.PACKAGE_JSON_EXISTS == 'true'
      with:
        node-version: 20.x

    - name: Set up NPM auth
      if: steps.check-package-json.outputs.PACKAGE_JSON_EXISTS == 'true'
      run: |
        npm config set //npm.pkg.github.com/:_authToken ${{ secrets.READ_PACKAGES_TOKEN }}
        npm config set @mindkomm:registry http://npm.pkg.github.com/

    - uses: bahmutov/npm-install@v1
      if: steps.check-package-json.outputs.PACKAGE_JSON_EXISTS == 'true'

    # Build assets
    - run: npm run build
      if: steps.check-package-json.outputs.PACKAGE_JSON_EXISTS == 'true'
      env:
        NODE_ENV: production

    # Remove unnecessary files using a cleanup configuration file.
    - run: |
        cleanup_file="${{ inputs.cleanup_file }}"
        
        if [ -f "$cleanup_file" ]; then
          echo "Found cleanup file: $cleanup_file"
          
          # Process each line in the cleanup file
          while IFS= read -r pattern || [ -n "$pattern" ]; do
            # Skip empty lines and comments (lines starting with #)
            if [ -z "$pattern" ] || [[ "$pattern" =~ ^[[:space:]]*# ]]; then
              continue
            fi
            
            # Trim whitespace
            pattern=$(echo "$pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            if [ -n "$pattern" ]; then
              echo "Processing pattern: $pattern"
              
              # Use find with -path for glob patterns, or rm for simple paths
              if [[ "$pattern" == *"*"* ]] || [[ "$pattern" == *"?"* ]]; then
                # Handle glob patterns with find
                find . -path "./$pattern" -delete 2>/dev/null || true
              else
                # Handle simple file/directory names
                if [ -e "$pattern" ]; then
                  echo "Removing: $pattern"
                  rm -rf "$pattern"
                fi
              fi
            fi
          done < "$cleanup_file"
          
          # Remove the cleanup file after processing
          echo "Removing cleanup file: $cleanup_file"
          rm -f "$cleanup_file"
          
        else
          echo "No cleanup file found at: $cleanup_file"
          echo "Using default cleanup patterns..."
          
          # Fallback to default behavior if no cleanup.txt exists
          rm -rf node_modules assets
          find . -type f -maxdepth 1 \( -name "webpack.config.js" -o -name "webpack.mix.js" -o -name "package.json" -o -name "package-lock.json" -o -name "babel.config.json" \) -exec rm {} \;
        fi

    # Compress all text files (gz and br) to be served as precompressed
    - run: |
        find . -type f \( -iname \*.css -o -iname \*.js -o -iname \*.svg -o -iname \*.html -o -iname \*.ics \) -exec gzip -k -9 -f {} \;
        find . -type f \( -iname \*.css -o -iname \*.js -o -iname \*.svg -o -iname \*.html -o -iname \*.ics \) -exec brotli  -f {} \;

    # Zip the package
    - run: |
        mkdir $GITHUB_WORKSPACE/../tmp
        mv $GITHUB_WORKSPACE/* $GITHUB_WORKSPACE/../tmp
        mkdir $GITHUB_WORKSPACE/${{ env.PACKAGE_NAME }}
        mv $GITHUB_WORKSPACE/../tmp/* $GITHUB_WORKSPACE/${{ env.PACKAGE_NAME }}
        zip -r -q $GITHUB_WORKSPACE/${{ steps.zip-filename.outputs.ZIP_FILENAME }} ${{ env.PACKAGE_NAME }}

    # Upload the package to the release
    - uses: AButler/upload-release-assets@v3.0
      with:
        files: "${{ steps.zip-filename.outputs.ZIP_FILENAME }}"
        release-tag: ${{ steps.tag.outputs.TAG }}
        repo-token: ${{ secrets.GITHUB_TOKEN }}
